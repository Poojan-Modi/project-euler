/*
Problem 12: Highly Divisible Triangular Number
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be:

1 + 2 + 3 + 4 + 5 + 6 + 7 = 28

The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

1: 1
3: 1, 3
6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
We can see that 28 is the first triangle number to have over five divisors.

Task
Write a program to find the first triangle number that has over N divisors.

Complexity
Time: O(nâˆšn) depending on how efficiently divisors are counted
Space: O(1) for tracking the current triangle number and divisor count

Solution: Caching and Sieve Technique
    1. Sieve of Eratosthenes - to precomute prime numbers for fast factoriazation
    2. Prime Factorization - to compute the number of divisors using the formula
        D(N) = (a_1 + 1) * (a_2 + 1) * (a_3 + 1) * ... * (a_k + 1)
    3. Caching - Store previously computed divisor counts to avoid redundant calculators

*/

#include <iostream>
#include <vector>
#include <cmath>
#include <unordered_map>
#include <chrono>

const int LIMIT {250
};
std::vector<int> primes;
std::unordered_map<int, int> divisor_cache;


/*
 * Sieve of Eratosthenes to generate primes
 *
 * @param {int} limit -> number of primes to be generated starting from first prime 2
*/
void generatePrimes(int limit)
{
    std::vector<bool> isPrime(limit + 1, true);
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i <= limit; ++i)
    {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j {i * 2}; j <= limit; j += i)
            {
                isPrime[j] = false;
            }
        }
    }
}


/*
 * Count Divisors using prime factorization
 *
 * @param {int} n -> coprime factors of tranigle number
 * @returns {int} count -> count of divisors of coprime number
 */
int countDivisors(int n)
{
    if (divisor_cache.count(n)) return divisor_cache[n];

    int original {n};
    int count {1};

    // loop through all primes
    for (int p : primes)
    {
        if (p * p > n) break;

        int exponent {0};
        //
        while (n % p == 0)
        {
            n /= p;
            ++exponent;
        }
        count *= (exponent + 1);
    }
    if (n > 1) count *= 2; // n is prime

    divisor_cache[original] = count;
    return count;
}


/*
 * Find the first triangle number with oven N divisors
 *
 * @param   {int} N -> target divisors min limit
 * @returns {int} triangle -> The number with more divisors than the limit
 */
int findTriangle(int N)
{
    generatePrimes(LIMIT);
    int n {1};
    while (true)
    {
        int triangle = n * (n + 1) / 2;

        // Use the factorization trick: n and n+1 are coprime
        int a {(n % 2 == 0) ? n / 2 : n};
        int b {(n % 2 == 0) ? n + 1 : (n + 1) / 2};

        int totalDivisors {countDivisors(a) * countDivisors(b)};
        if (totalDivisors > N) return triangle;

        ++n;
    }
}


int main()
{
    auto start {std::chrono::high_resolution_clock::now()};

    const int N {500};
    int triangle {findTriangle(N)};

    std::cout << "First triangle number with over " << N << " divisors: " << triangle << "\n";

    auto end {std::chrono::high_resolution_clock::now()};
    std::chrono::duration<double> duration = end - start;
    std::cout << "Exacution Time: " << duration.count() << " seconds\n";
    return 0;
}

