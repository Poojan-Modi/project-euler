/*
Problem 12: Highly Divisible Triangular Number

The sequence of triangle numbers is generated by adding natural numbers.
For example, the 7th triangle number is:
1 + 2 + 3 + 4 + 5 + 6 + 7 = 28

The first ten triangle numbers are:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let’s list the factors of the first few triangle numbers:
1: 1
3: 1, 3
6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28

We can see that 28 is the first triangle number to have over five divisors.

Task:
Write a program to find the first triangle number that has over N divisors.

Complexity:
Time: O(n√n), depending on how efficiently divisors are counted
Space: O(1), for tracking the current triangle number and divisor count

Optimizations:
1. Sieve of Eratosthenes – to precompute prime numbers for fast factorization
2. Prime Factorization – to compute the formula:
   D(N) = (a₁ + 1) * (a₂ + 1) * (a₃ + 1) * ... * (aₖ + 1)
3. Caching – store previously computed divisor counts to avoid redundant calculations
*/

#include <iostream>
#include <vector>
#include <cmath>
#include <unordered_map>
#include <chrono>

const int LIMIT{250};
std::vector<int> primes;
std::unordered_map<int, int> divisor_cache;

/*
 * Generate prime numbers using the Sieve of Eratosthenes
 *
 * @param limit - upper bound for prime generation
 */
void generatePrimes(int limit)
{
    std::vector<bool> isPrime(limit + 1, true);
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i <= limit; ++i)
    {
        if (isPrime[i])
        {
            primes.push_back(i);
            for (int j{i * 2}; j <= limit; j += i)
            {
                isPrime[j] = false;
            }
        }
    }
}

/*
 * Count the number of divisors using prime factorization
 *
 * @param n - the number to factorize
 * @return count - total number of divisors
 */
int countDivisors(int n)
{
    if (divisor_cache.count(n))
        return divisor_cache[n];

    int original{n};
    int count{1};

    for (int p : primes)
    {
        if (p * p > n)
            break;

        int exponent{0};
        while (n % p == 0)
        {
            n /= p;
            ++exponent;
        }
        count *= (exponent + 1);
    }

    if (n > 1)
        count *= 2; // n is prime

    divisor_cache[original] = count;
    return count;
}

/*
 * Find the first triangle number with more than N divisors
 *
 * @param N - minimum number of divisors required
 * @return triangle - the first triangle number with over N divisors
 */
int findTriangle(int N)
{
    generatePrimes(LIMIT);
    int n{1};
    while (true)
    {
        int triangle = n * (n + 1) / 2;

        // Use the factorization trick: n and n+1 are coprime
        int a{(n % 2 == 0) ? n / 2 : n};
        int b{(n % 2 == 0) ? n + 1 : (n + 1) / 2};

        int totalDivisors{countDivisors(a) * countDivisors(b)};
        if (totalDivisors > N)
            return triangle;

        ++n;
    }
}

int main()
{
    auto start{std::chrono::high_resolution_clock::now()};

    const int N{500};
    int triangle{findTriangle(N)};

    std::cout << "First triangle number with over " << N << " divisors: " << triangle << "\n";

    auto end{std::chrono::high_resolution_clock::now()};
    std::chrono::duration<double> duration = end - start;
    std::cout << "Execution Time: " << duration.count() << " seconds\n";

    return 0;
}
