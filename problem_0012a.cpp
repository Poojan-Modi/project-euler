/*
Problem 12: Highly Divisible Triangular Number
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be:

1 + 2 + 3 + 4 + 5 + 6 + 7 = 28

The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

1: 1
3: 1, 3
6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
We can see that 28 is the first triangle number to have over five divisors.

Task
Write a program to find the first triangle number that has over N divisors.

Complexity
Time: O(nâˆšn) depending on how efficiently divisors are counted
Space: O(1) for tracking the current triangle number and divisor count

Solution: Efficient Divisor Counting
N   ->  Integer
pn  ->  Distinct prime number
an  ->  Exponent

N = p1^a1 * p2^a2 *  p3^a3 * ...

D(N)    ->  Number of divisors of any integer N
D(N) =  (a1+1) * (a2+1) * (a3+1) * ...

Note:

Tn  ->  N-th triangle is

Tn = n * (n + 1) / 2

*/

#include <iostream>
#include <chrono>

/*
 * This function counts the divisors of the specific trangle number with the prime factorization method
 *
 * @param   {int} n - The number who's divisors are being counted
 * @returns  {int} count - the number of divisors of n
 */
int countDivisors(int n)
{
    int count{0};
    for (int i{1}; i * i <= n; ++i)
    {
        if (n % i == 0)
        {
            count += (i * i == n) ? 1 : 2;
        }
    }
    return count;
}

/*
 * Optimized divisor count for triangle numbers using coprime factorization
 *
 * @param   {int} n
 * @returns  {int} countDivisors(a) * countDivisors(b)
 */

int countDivisorsTriangle(int n)
{
    int a{(n % 2 == 0) ? n / 2 : n};
    int b{(n % 2 == 0) ? n + 1 : (n + 1) / 2};
    return countDivisors(a) * countDivisors(b);
}

/*
 * This Function finds the first triangle number with more divisors than the specified limit
 *
 * @param   {int} limit - The minimum number of divisors for the triangle number being searched for
 * @returns {int} triangle - The number with more divisors than the limit
 */
long long findTriangle(int limit)
{
    int n{1};
    while (true)
    {
        if (countDivisorsTriangle(n) > limit)
            return static_cast<long long>(n) * (n + 1) / 2;

        ++n;
    }
    return 0;
}

int main()
{
    auto start{std::chrono::high_resolution_clock::now()};

    const int limit{500};
    long long triangle{findTriangle(limit)};

    std::cout << "First triangle number with over " << limit << " divisors: " << triangle << "\n";

    auto end{std::chrono::high_resolution_clock::now()};
    std::chrono::duration<double> duration = end - start;
    std::cout << "Exacution Time: " << duration.count() << " seconds\n";
    return 0;
}
